<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lifting Biomechanics Simulator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #111827; /* gray-900 */
            color: #f3f4f6; /* gray-100 */
            overscroll-behavior: none;
        }
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap');
        
        #canvas-container {
            width: 100%;
            height: 100%;
            position: relative;
        }
        canvas {
            display: block;
        }
        
        /* Custom slider styles */
        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 8px;
            border-radius: 4px;
            background: #374151; /* gray-700 */
            outline: none;
            opacity: 0.7;
            transition: opacity .2s;
        }
        input[type="range"]:hover {
            opacity: 1;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #3b82f6; /* blue-500 */
            cursor: pointer;
        }
        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #3b82f6; /* blue-500 */
            cursor: pointer;
        }
        
        #readouts {
            position: absolute;
            top: 20px;
            right: 20px;
            background-color: rgba(17, 24, 39, 0.8); /* gray-900 with opacity */
            padding: 16px;
            border-radius: 8px;
            border: 1px solid #374151; /* gray-700 */
            font-family: 'Courier New', Courier, monospace;
        }
    </style>
</head>
<body class="w-full h-screen m-0 p-0 flex overflow-hidden">

    <!-- CONTROLS SIDEBAR -->
    <div class="w-full max-w-xs p-6 bg-gray-800 h-screen overflow-y-auto shadow-xl">
        <h1 class="text-2xl font-bold mb-6 text-white">Lift Simulator</h1>
        
        <div class="space-y-6">
            <!-- Animation Controls -->
            <div>
                <h2 class="text-sm font-semibold text-blue-400 mb-3">ANIMATION</h2>
                <label for="animation-slider" class="text-sm text-gray-300 block mb-1">Lift Progress (0% to 100%)</label>
                <div class="flex items-center space-x-2">
                    <span class="text-xs text-gray-400">Up</span>
                    <input id="animation-slider" type="range" min="0" max="1" step="0.01" value="0">
                    <span class="text-xs text-gray-400">Down</span>
                </div>
            </div>

            <!-- Anthropometrics -->
            <div>
                <h2 class="text-sm font-semibold text-blue-400 mb-3">ANTHROPOMETRICS</h2>
                <div class="space-y-4">
                    <div>
                        <label for="torso-slider" class="text-sm text-gray-300 block mb-1">Torso Length: <span id="torso-val" class="font-medium text-white">1.0</span></label>
                        <input id="torso-slider" type="range" min="0.8" max="1.2" step="0.01" value="1.0">
                    </div>
                    <div>
                        <label for="femur-slider" class="text-sm text-gray-300 block mb-1">Femur Length: <span id="femur-val" class="font-medium text-white">1.0</span></label>
                        <input id="femur-slider" type="range" min="0.8" max="1.2" step="0.01" value="1.0">
                    </div>
                    <div>
                        <label for="tibia-slider" class="text-sm text-gray-300 block mb-1">Tibia Length: <span id="tibia-val" class="font-medium text-white">1.0</span></label>
                        <input id="tibia-slider" type="range" min="0.8" max="1.2" step="0.01" value="1.0">
                    </div>
                </div>
            </div>

            <!-- Lift Setup -->
            <div>
                <h2 class="text-sm font-semibold text-blue-400 mb-3">LIFT SETUP (SQUAT)</h2>
                <div class="space-y-4">
                    <div>
                        <label for="bar-slider" class="text-sm text-gray-300 block mb-1">Bar Position (High/Low): <span id="bar-val" class="font-medium text-white">0.0</span></label>
                        <input id="bar-slider" type="range" min="-0.1" max="0.1" step="0.01" value="0.0">
                        <div class="flex justify-between text-xs text-gray-400">
                            <span>Low Bar</span>
                            <span>High Bar</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- 3D CANVAS -->
    <div id="canvas-container" class="flex-1">
        <!-- JS-controlled readout -->
        <div id="readouts" class="text-sm text-gray-300 space-y-2">
            <div>Hip Angle: <span id="hip-angle" class="font-bold text-white">0.0°</span></div>
            <div>Knee Angle: <span id="knee-angle" class="font-bold text-white">0.0°</span></div>
            <div>Ankle Angle: <span id="ankle-angle" class="font-bold text-white">0.0°</span></div>
            <div class="pt-2 border-t border-gray-700 mt-2">Lever Arm: <span id="lever-arm" class="font-bold text-white">0.00</span></div>
        </div>
    </div>

    <!-- THREE.JS SCRIPT -->
    <script type="module">
        import * as THREE from 'https://cdn.skypack.dev/three@0.132.2';

        // --- GLOBAL VARS ---
        let scene, camera, renderer;
        let skeleton = {};
        let helpers = {};
        let startBarWorldX = 0; // The X-position of the bar at t=0
        
        // --- Keyframes for Squat (Angles in Radians) ---
        // These define the *movement*, not the *proportions*
        // We removed hipPos, as it will be calculated by our IK solver
        const squatStart = {
            hipAngle: 0,        // 0 = fully extended
            kneeAngle: 0,       // 0 = fully extended
            ankleAngle: 0,      // 0 = 90 deg relative to tibia
        };
        const squatEnd = {
            hipAngle: -2.1,     // ~120 degrees flexion
            kneeAngle: -2.1,    // ~120 degrees flexion
            ankleAngle: -0.6,   // ~35 degrees dorsiflexion
        };
        
        // --- DOM Elements ---
        const container = document.getElementById('canvas-container');
        const readoutHip = document.getElementById('hip-angle');
        const readoutKnee = document.getElementById('knee-angle');
        const readoutAnkle = document.getElementById('ankle-angle');
        const readoutLever = document.getElementById('lever-arm');

        // --- Sliders ---
        const animSlider = document.getElementById('animation-slider');
        const torsoSlider = document.getElementById('torso-slider');
        const femurSlider = document.getElementById('femur-slider');
        const tibiaSlider = document.getElementById('tibia-slider');
        const barSlider = document.getElementById('bar-slider');
        
        // --- Value Labels ---
        const torsoVal = document.getElementById('torso-val');
        const femurVal = document.getElementById('femur-val');
        const tibiaVal = document.getElementById('tibia-val');
        const barVal = document.getElementById('bar-val');

        // --- INIT ---
        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x111827); // gray-900

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            container.appendChild(renderer.domElement);

            // Camera
            const aspect = container.clientWidth / container.clientHeight;
            const viewSize = 6; // Controls zoom
            camera = new THREE.OrthographicCamera(
                -viewSize * aspect / 2, 
                viewSize * aspect / 2, 
                viewSize / 2, 
                -viewSize / 2, 
                0.1, 
                100
            );
            camera.position.set(0, 2.5, 10);
            camera.lookAt(0, 2.5, 0);

            // Lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 10, 7.5);
            scene.add(directionalLight);
            
            // Floor
            const floorGeo = new THREE.BoxGeometry(10, 0.1, 10);
            const floorMat = new THREE.MeshStandardMaterial({ color: 0x374151 }); // gray-700
            const floor = new THREE.Mesh(floorGeo, floorMat);
            floor.position.set(0, -0.05, 0);
            scene.add(floor);

            // Create Skeleton
            createSkeleton();
            
            // Create Helpers
            createHelpers();

            // Add Event Listeners
            addEventListeners();
            
            // Initial Update
            updateModelProportions(); // This will also call updateAnimation(t=0)
            
            // Get the starting bar position AFTER the initial render
            // This is our "golden" X coordinate for the vertical bar path
            const barPos = new THREE.Vector3();
            skeleton.bar.getWorldPosition(barPos);
            startBarWorldX = barPos.x;
            helpers.barPathLine.position.x = startBarWorldX;

            // Start Render Loop
            animate();
        }

        // --- CREATE SKELETON ---
        function createSkeleton() {
            const limbMaterial = new THREE.MeshStandardMaterial({ color: 0xf3f4f6 }); // gray-100
            const jointMaterial = new THREE.MeshStandardMaterial({ color: 0x3b82f6 }); // blue-500
            const barMaterial = new THREE.MeshStandardMaterial({ color: 0xef4444 }); // red-500

            const limbWidth = 0.05;
            const jointRadius = 0.07;

            // --- Geometries ---
            const footGeo = new THREE.BoxGeometry(0.5, limbWidth, limbWidth);
            const tibiaGeo = new THREE.BoxGeometry(limbWidth, 1, limbWidth);
            const femurGeo = new THREE.BoxGeometry(limbWidth, 1, limbWidth);
            const torsoGeo = new THREE.BoxGeometry(limbWidth * 2, 1, limbWidth * 2);
            const barGeo = new THREE.CylinderGeometry(0.04, 0.04, 1.5, 16);
            barGeo.rotateZ(Math.PI / 2); // Make it horizontal
            
            const jointGeo = new THREE.SphereGeometry(jointRadius, 16, 16);

            // --- Parts (Meshes) ---
            skeleton.foot = new THREE.Mesh(footGeo, limbMaterial);
            skeleton.tibia = new THREE.Mesh(tibiaGeo, limbMaterial);
            skeleton.femur = new THREE.Mesh(femurGeo, limbMaterial);
            skeleton.torso = new THREE.Mesh(torsoGeo, limbMaterial);
            skeleton.bar = new THREE.Mesh(barGeo, barMaterial);
            
            // --- Visible Joints (Meshes) ---
            skeleton.ankleJoint = new THREE.Mesh(jointGeo, jointMaterial);
            skeleton.kneeJoint = new THREE.Mesh(jointGeo, jointMaterial);
            skeleton.hipJoint = new THREE.Mesh(jointGeo, jointMaterial);
            skeleton.shoulderJoint = new THREE.Mesh(jointGeo, jointMaterial);

            // --- Pivots (Groups) ---
            // We build the hierarchy from the ground up
            skeleton.ankle = new THREE.Group();
            skeleton.knee = new THREE.Group();
            skeleton.hip = new THREE.Group();
            skeleton.shoulder = new THREE.Group(); // Pivot for the bar
            
            // --- Assemble Hierarchy ---
            scene.add(skeleton.ankle);
            skeleton.ankle.add(skeleton.foot);
            skeleton.ankle.add(skeleton.tibia);
            skeleton.ankle.add(skeleton.ankleJoint);
            skeleton.ankle.add(skeleton.knee);
            
            skeleton.knee.add(skeleton.femur);
            skeleton.knee.add(skeleton.kneeJoint);
            skeleton.knee.add(skeleton.hip);
            
            skeleton.hip.add(skeleton.torso);
            skeleton.hip.add(skeleton.hipJoint);
            skeleton.hip.add(skeleton.shoulder);
            
            skeleton.shoulder.add(skeleton.bar);
            skeleton.shoulder.add(skeleton.shoulderJoint);
            
            // Set base positions
            skeleton.ankle.position.y = jointRadius; // Set ankle pivot at joint radius height
            skeleton.foot.position.x = 0.15; // Place heel at 0, mid-foot forward
        }
        
        // --- CREATE HELPERS ---
        function createHelpers() {
            // Lever arm line
            const lineMat = new THREE.LineBasicMaterial({ color: 0xfbbf24 }); // amber-400
            const points = [new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, 0)];
            const lineGeo = new THREE.BufferGeometry().setFromPoints(points);
            helpers.leverArmLine = new THREE.Line(lineGeo, lineMat);
            helpers.leverArmLine.position.z = 0.5; // Bring in front
            scene.add(helpers.leverArmLine);
            
            // Bar path line (vertical)
            const barPathMat = new THREE.LineBasicMaterial({ color: 0xef4444, dashed: true, dashSize: 0.1, gapSize: 0.05 });
            const barPoints = [new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 5, 0)];
            const barPathGeo = new THREE.BufferGeometry().setFromPoints(barPoints);
            helpers.barPathLine = new THREE.Line(barPathGeo, barPathMat);
            helpers.barPathLine.position.z = 0.4;
            // We now set the X position in init()
            scene.add(helpers.barPathLine);
        }

        // --- EVENT LISTENERS ---
        function addEventListeners() {
            window.addEventListener('resize', onWindowResize);
            
            // Link sliders to update functions
            [torsoSlider, femurSlider, tibiaSlider, barSlider].forEach(slider => {
                slider.addEventListener('input', updateModelProportions);
            });
            
            animSlider.addEventListener('input', updateAnimation);

            // Link sliders to value labels
            torsoSlider.addEventListener('input', (e) => torsoVal.textContent = parseFloat(e.target.value).toFixed(2));
            femurSlider.addEventListener('input', (e) => femurVal.textContent = parseFloat(e.target.value).toFixed(2));
            tibiaSlider.addEventListener('input', (e) => tibiaVal.textContent = parseFloat(e.target.value).toFixed(2));
            barSlider.addEventListener('input', (e) => barVal.textContent = parseFloat(e.target.value).toFixed(2));
        }

        // --- UPDATE MODEL PROPORTIONS (from Sliders) ---
        function updateModelProportions() {
            const torsoLength = parseFloat(torsoSlider.value);
            const femurLength = parseFloat(femurSlider.value);
            const tibiaLength = parseFloat(tibiaSlider.value);
            const barOffset = parseFloat(barSlider.value);
            
            // Scale the limbs and position the next joint
            // Tibia
            skeleton.tibia.scale.y = tibiaLength;
            skeleton.tibia.position.y = tibiaLength / 2;
            skeleton.knee.position.y = tibiaLength; // Move knee joint to top of tibia
            
            // Femur
            skeleton.femur.scale.y = femurLength;
            skeleton.femur.position.y = femurLength / 2;
            skeleton.hip.position.y = femurLength; // Move hip joint to top of femur
            
            // Torso
            skeleton.torso.scale.y = torsoLength;
            skeleton.torso.position.y = torsoLength / 2;
            skeleton.shoulder.position.y = torsoLength * 0.9; // Shoulder near top
            
            // Bar
            skeleton.bar.position.y = barOffset; // Relative to shoulder
            
            // When proportions change, we MUST reset the animation and recalculate
            // the starting bar position.
            animSlider.value = "0";
            updateAnimation(); // Apply t=0 angles
            
            // Recalculate the baseline bar X-position
            const barPos = new THREE.Vector3();
            skeleton.bar.getWorldPosition(barPos);
            startBarWorldX = barPos.x;
            helpers.barPathLine.position.x = startBarWorldX;
            
            // Run updateAnimation again to apply the correction with the new startX
            updateAnimation();
        }

        // --- UPDATE ANIMATION (from Slider) ---
        function updateAnimation() {
            const t = parseFloat(animSlider.value); // 0.0 to 1.0

            // 1. Reset horizontal position of the skeleton root
            skeleton.ankle.position.x = 0;

            // 2. Interpolate and apply angles
            const hipAngle = THREE.MathUtils.lerp(squatStart.hipAngle, squatEnd.hipAngle, t);
            const kneeAngle = THREE.MathUtils.lerp(squatStart.kneeAngle, squatEnd.kneeAngle, t);
            const ankleAngle = THREE.MathUtils.lerp(squatStart.ankleAngle, squatEnd.ankleAngle, t);
            
            // Apply rotations
            // Note: We use rotation.z for 2D side-view rotation
            skeleton.hip.rotation.z = hipAngle;
            skeleton.knee.rotation.z = kneeAngle;
            skeleton.ankle.rotation.z = ankleAngle;

            // 3. Force update the world matrix to get the new bar position
            skeleton.ankle.updateWorldMatrix(true, false);

            // 4. Get the "uncorrected" bar position
            const barPos = new THREE.Vector3();
            skeleton.bar.getWorldPosition(barPos);
            
            // 5. Calculate the correction needed to keep bar vertical
            const correctionX = startBarWorldX - barPos.x;
            
            // 6. Apply the correction to the root of the skeleton
            skeleton.ankle.position.x = correctionX;
            
            // 7. Update readouts
            // Hip angle is relative to torso (0 = straight)
            // Knee angle is relative to femur (0 = straight)
            // Ankle angle is relative to tibia (0 = 90 deg)
            const hipDeg = THREE.MathUtils.radToDeg(hipAngle);
            const kneeDeg = THREE.MathUtils.radToDeg(kneeAngle);
            const ankleDeg = THREE.MathUtils.radToDeg(ankleAngle);
            
            // We want to show internal joint angles
            readoutHip.textContent = `${(180 + hipDeg).toFixed(1)}°`;
            readoutKnee.textContent = `${(180 + kneeDeg).toFixed(1)}°`;
            readoutAnkle.textContent = `${(90 - ankleDeg).toFixed(1)}°`;
            
            // 8. Update helpers
            updateHelpers();
        }
        
        // --- UPDATE HELPERS (Lever Arm, etc.) ---
        function updateHelpers() {
            // Get world positions
            const hipPos = new THREE.Vector3();
            // We don't need barPos, since we know its X is startBarWorldX
            
            skeleton.hip.getWorldPosition(hipPos);
            
            // Update Lever Arm Line
            const leverArmPoints = [];
            const leverArmX = startBarWorldX; // Bar is forced to this X
            leverArmPoints.push(new THREE.Vector3(hipPos.x, hipPos.y, 0.5));
            leverArmPoints.push(new THREE.Vector3(leverArmX, hipPos.y, 0.5));
            helpers.leverArmLine.geometry.setFromPoints(leverArmPoints);
            helpers.leverArmLine.geometry.attributes.position.needsUpdate = true;
            
            // Update Lever Arm Readout
            const leverArmLength = Math.abs(hipPos.x - leverArmX);
            readoutLever.textContent = leverArmLength.toFixed(2);
            
            // Bar path line is now static, no update needed here
        }

        // --- RESIZE ---
        function onWindowResize() {
            const w = container.clientWidth;
            const h = container.clientHeight;
            
            renderer.setSize(w, h);
            
            const aspect = w / h;
            const viewSize = 6;
            camera.left = -viewSize * aspect / 2;
            camera.right = viewSize * aspect / 2;
            camera.top = viewSize / 2;
            camera.bottom = -viewSize / 2;
            camera.updateProjectionMatrix();
        }

        // --- RENDER LOOP ---
        function animate() {
            requestAnimationFrame(animate);
            // In this version, animation is driven by the slider,
            // so we just need to render the current state.
            renderer.render(scene, camera);
        }

        // --- START ---
        init();

    </script>
</body>
</html>