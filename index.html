<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lifting Biomechanics Simulator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #111827; /* gray-900 */
            color: #f3f4f6; /* gray-100 */
            overscroll-behavior: none;
        }
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap');
        
        #canvas-container {
            width: 100%;
            height: 100%;
            position: relative;
        }
        canvas {
            display: block;
        }
        
        /* Custom slider styles */
        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 8px;
            border-radius: 4px;
            background: #374151; /* gray-700 */
            outline: none;
            opacity: 0.7;
            transition: opacity .2s;
        }
        input[type="range"]:hover {
            opacity: 1;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #3b82f6; /* blue-500 */
            cursor: pointer;
        }
        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #3b82f6; /* blue-500 */
            cursor: pointer;
        }
        
        #readouts {
            position: absolute;
            top: 20px;
            right: 20px;
            background-color: rgba(17, 24, 39, 0.8); /* gray-900 with opacity */
            padding: 16px;
            border-radius: 8px;
            border: 1px solid #374151; /* gray-700 */
            font-family: 'Courier New', Courier, monospace;
        }
    </style>
</head>
<body class="w-full h-screen m-0 p-0 flex overflow-hidden">

    <!-- CONTROLS SIDEBAR -->
    <div class="w-full max-w-xs p-6 bg-gray-800 h-screen overflow-y-auto shadow-xl">
        <h1 class="text-2xl font-bold mb-6 text-white">Lift Simulator</h1>
        
        <div class="space-y-6">
            <!-- Animation Controls -->
            <div>
                <h2 class="text-sm font-semibold text-blue-400 mb-3">ANIMATION</h2>
                <label for="animation-slider" class="text-sm text-gray-300 block mb-1">Lift Progress (0% to 100%)</label>
                <div class="flex items-center space-x-2">
                    <span class="text-xs text-gray-400">Up</span>
                    <input id="animation-slider" type="range" min="0" max="1" step="0.01" value="0">
                    <span class="text-xs text-gray-400">Down</span>
                </div>
            </div>

            <!-- Anthropometrics -->
            <div>
                <h2 class="text-sm font-semibold text-blue-400 mb-3">ANTHROPOMETRICS</h2>
                <div class="space-y-4">
                    <div>
                        <label for="torso-slider" class="text-sm text-gray-300 block mb-1">Torso Length: <span id="torso-val" class="font-medium text-white">1.0</span></label>
                        <input id="torso-slider" type="range" min="0.8" max="1.2" step="0.01" value="1.0">
                    </div>
                    <div>
                        <label for="femur-slider" class="text-sm text-gray-300 block mb-1">Femur Length: <span id="femur-val" class="font-medium text-white">1.0</span></label>
                        <input id="femur-slider" type="range" min="0.8" max="1.2" step="0.01" value="1.0">
                    </div>
                    <div>
                        <label for="tibia-slider" class="text-sm text-gray-300 block mb-1">Tibia Length: <span id="tibia-val" class="font-medium text-white">1.0</span></label>
                        <input id="tibia-slider" type="range" min="0.8" max="1.2" step="0.01" value="1.0">
                    </div>
                </div>
            </div>

            <!-- Bar Marker Placement -->
            <div>
                <h2 class="text-sm font-semibold text-blue-400 mb-3">BAR MARKER</h2>
                <label for="bar-slider" class="text-sm text-gray-300 block mb-1">Marker Height: <span id="bar-val" class="font-medium text-white">0.50</span></label>
                <input id="bar-slider" type="range" min="0" max="1" step="0.01" value="0.5">
                <div class="flex justify-between text-xs text-gray-400">
                    <span>Low Bar</span>
                    <span>High Bar</span>
                </div>
            </div>

        </div>
    </div>

    <!-- 3D CANVAS -->
    <div id="canvas-container" class="flex-1">
        <!-- JS-controlled readout -->
        <div id="readouts" class="text-sm text-gray-300 space-y-2">
            <div>Hip Angle: <span id="hip-angle" class="font-bold text-white">0.0°</span></div>
            <div>Knee Angle: <span id="knee-angle" class="font-bold text-white">0.0°</span></div>
            <div>Ankle Angle: <span id="ankle-angle" class="font-bold text-white">0.0°</span></div>
        </div>
    </div>

    <!-- THREE.JS SCRIPT -->
    <script type="module">
        import * as THREE from 'https://cdn.skypack.dev/three@0.132.2';

        const LIMB_WIDTH = 0.05;
        const JOINT_RADIUS = 0.07;
        const HEAD_RADIUS = 0.15;
    const FOOT_LENGTH = 0.5;
    const FOOT_FORWARD = 0.18;
    const DEPTH_MARGIN = 0.02;
    const DEPTH_START_RATIO = 0.6;
    const ALIGN_START_RATIO = 0.1;
    const HIP_MIN = THREE.MathUtils.degToRad(-160);
    const HIP_MAX = THREE.MathUtils.degToRad(45);
    const START_ALIGN_WEIGHT = 0.25;

    let scene, camera, renderer;
    const skeleton = {};
    const tempVec1 = new THREE.Vector3();
    const tempVec2 = new THREE.Vector3();
    const tempVec3 = new THREE.Vector3();
    let hipBaseOffset = 0;
    let previousAnimValue = null;
    let previousHipAngle = null;

        const container = document.getElementById('canvas-container');
        const readoutHip = document.getElementById('hip-angle');
        const readoutKnee = document.getElementById('knee-angle');
        const readoutAnkle = document.getElementById('ankle-angle');

        const animSlider = document.getElementById('animation-slider');
        const torsoSlider = document.getElementById('torso-slider');
        const femurSlider = document.getElementById('femur-slider');
        const tibiaSlider = document.getElementById('tibia-slider');
        const barSlider = document.getElementById('bar-slider');

        const torsoVal = document.getElementById('torso-val');
        const femurVal = document.getElementById('femur-val');
        const tibiaVal = document.getElementById('tibia-val');
        const barVal = document.getElementById('bar-val');

        const squatStart = {
            hipFlex: THREE.MathUtils.degToRad(0),
            kneeFlex: THREE.MathUtils.degToRad(0),
            ankleFlex: THREE.MathUtils.degToRad(0)
        };

        const squatEnd = {
            hipFlex: THREE.MathUtils.degToRad(-150),  // deeper torso lean over femur
            kneeFlex: THREE.MathUtils.degToRad(-170), // additional knee flexion to drop hip
            ankleFlex: THREE.MathUtils.degToRad(-42)  // extra dorsiflexion to keep balance
        };

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x111827);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            container.appendChild(renderer.domElement);

            const aspect = container.clientWidth / container.clientHeight;
            const viewSize = 6;
            camera = new THREE.OrthographicCamera(
                -viewSize * aspect / 2,
                viewSize * aspect / 2,
                viewSize / 2,
                -viewSize / 2,
                0.1,
                100
            );
            camera.position.set(5, 3, 8);
            camera.lookAt(0, 2.5, 0);

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.9);
            directionalLight.position.set(5, 8, 10);
            scene.add(directionalLight);

            const floorGeo = new THREE.BoxGeometry(10, 0.1, 10);
            const floorMat = new THREE.MeshStandardMaterial({ color: 0x374151 });
            const floor = new THREE.Mesh(floorGeo, floorMat);
            floor.position.set(0, -0.05, 0);
            scene.add(floor);

            createSkeleton();
            calibrateHipBase();
            addEventListeners();
            updateModelProportions();
            animate();
        }

        function createSkeleton() {
            const limbMaterial = new THREE.MeshStandardMaterial({ color: 0xf3f4f6 });
            const jointMaterial = new THREE.MeshStandardMaterial({ color: 0x3b82f6 });

            const footGeo = new THREE.BoxGeometry(FOOT_LENGTH, LIMB_WIDTH, LIMB_WIDTH);
            const tibiaGeo = new THREE.BoxGeometry(LIMB_WIDTH, 1, LIMB_WIDTH);
            const femurGeo = new THREE.BoxGeometry(LIMB_WIDTH, 1, LIMB_WIDTH);
            const torsoGeo = new THREE.BoxGeometry(LIMB_WIDTH * 2.2, 1, LIMB_WIDTH * 2.2);
            const headGeo = new THREE.SphereGeometry(HEAD_RADIUS, 16, 16);
            const jointGeo = new THREE.SphereGeometry(JOINT_RADIUS, 16, 16);
            const markerGeo = new THREE.SphereGeometry(0.06, 16, 16);

            skeleton.foot = new THREE.Mesh(footGeo, limbMaterial);
            skeleton.tibia = new THREE.Mesh(tibiaGeo, limbMaterial);
            skeleton.femur = new THREE.Mesh(femurGeo, limbMaterial);
            skeleton.torso = new THREE.Mesh(torsoGeo, limbMaterial);
            skeleton.head = new THREE.Mesh(headGeo, limbMaterial);
            skeleton.barMarker = new THREE.Mesh(markerGeo, new THREE.MeshStandardMaterial({ color: 0xef4444, emissive: 0x7f1d1d, emissiveIntensity: 0.6 }));

            skeleton.ankleJoint = new THREE.Mesh(jointGeo, jointMaterial);
            skeleton.kneeJoint = new THREE.Mesh(jointGeo, jointMaterial);
            skeleton.hipJoint = new THREE.Mesh(jointGeo, jointMaterial);

            skeleton.ankle = new THREE.Group();
            skeleton.ankleRotator = new THREE.Group();
            skeleton.knee = new THREE.Group();
            skeleton.femurGroup = new THREE.Group();
            skeleton.hip = new THREE.Group();

            scene.add(skeleton.ankle);

            skeleton.ankle.add(skeleton.foot);
            skeleton.ankle.add(skeleton.ankleJoint);
            skeleton.ankle.add(skeleton.ankleRotator);

            skeleton.ankleRotator.add(skeleton.tibia);
            skeleton.ankleRotator.add(skeleton.kneeJoint);
            skeleton.ankleRotator.add(skeleton.knee);

            skeleton.knee.add(skeleton.femurGroup);

            skeleton.femurGroup.add(skeleton.femur);
            skeleton.femurGroup.add(skeleton.hipJoint);
            skeleton.femurGroup.add(skeleton.hip);

            skeleton.hip.add(skeleton.torso);
            skeleton.hip.add(skeleton.head);
            skeleton.torso.add(skeleton.barMarker);

            skeleton.ankle.position.set(0, JOINT_RADIUS + LIMB_WIDTH / 2, 0);
            skeleton.foot.position.set(FOOT_FORWARD, -JOINT_RADIUS, 0);
            skeleton.ankleJoint.position.set(0, 0, 0);

            skeleton.tibia.position.set(0, 0.5, 0);
            skeleton.knee.position.set(0, 1, 0);
            skeleton.kneeJoint.position.set(0, 1, 0);

            skeleton.femur.position.set(0, 0.5, 0);
            skeleton.hip.position.set(0, 1, 0);
            skeleton.hipJoint.position.set(0, 1, 0);

            skeleton.torso.position.set(0, 0.5, 0);
            skeleton.head.position.set(0, 1.1, 0);
            skeleton.barMarker.position.set(0, 0, LIMB_WIDTH * 2.5);
        }

        function addEventListeners() {
            window.addEventListener('resize', onWindowResize);

            [torsoSlider, femurSlider, tibiaSlider].forEach(slider => {
                slider.addEventListener('input', updateModelProportions);
            });

            animSlider.addEventListener('input', updateAnimation);

            torsoSlider.addEventListener('input', (e) => torsoVal.textContent = parseFloat(e.target.value).toFixed(2));
            femurSlider.addEventListener('input', (e) => femurVal.textContent = parseFloat(e.target.value).toFixed(2));
            tibiaSlider.addEventListener('input', (e) => tibiaVal.textContent = parseFloat(e.target.value).toFixed(2));
            barSlider.addEventListener('input', () => {
                updateBarMarkerPosition();
                calibrateHipBase();
                updateAnimation();
            });
        }

        function updateBarMarkerPosition() {
            if (!skeleton.barMarker) return;
            const placement = parseFloat(barSlider.value);
            const normalizedY = THREE.MathUtils.lerp(-0.15, 0.4, placement);
            skeleton.barMarker.position.y = normalizedY;
            skeleton.barMarker.position.z = LIMB_WIDTH * 2.5;
            barVal.textContent = placement.toFixed(2);
        }

        function calibrateHipBase() {
            if (!skeleton.hip) return;

            skeleton.ankleRotator.rotation.z = squatStart.ankleFlex;
            skeleton.femurGroup.rotation.z = squatStart.ankleFlex - squatStart.kneeFlex;
            skeleton.hip.rotation.z = 0;

            skeleton.ankle.position.x = 0;
            skeleton.foot.position.x = FOOT_FORWARD;

            const MAX_ITER = 12;
            const MAX_DELTA = 0.12;
            let hipAngle = 0;

            for (let i = 0; i < MAX_ITER; i++) {
                skeleton.ankle.updateWorldMatrix(true, false);
                skeleton.barMarker.getWorldPosition(tempVec1);
                skeleton.hip.getWorldPosition(tempVec2);
                skeleton.foot.getWorldPosition(tempVec3);

                const error = tempVec3.x - tempVec1.x;
                if (Math.abs(error) < 5e-5) break;

                const relative = tempVec1.clone().sub(tempVec2);
                const derivative = -relative.y;
                if (Math.abs(derivative) < 1e-4) break;

                let delta = error / derivative;
                if (!Number.isFinite(delta)) break;
                delta = THREE.MathUtils.clamp(delta, -MAX_DELTA, MAX_DELTA);
                hipAngle = THREE.MathUtils.clamp(hipAngle + delta, HIP_MIN, HIP_MAX);
                skeleton.hip.rotation.z = hipAngle;
            }

            hipBaseOffset = hipAngle;
            skeleton.hip.rotation.z = 0;
            previousAnimValue = null;
            previousHipAngle = null;
        }

        function updateModelProportions() {
            const torsoLength = parseFloat(torsoSlider.value);
            const femurLength = parseFloat(femurSlider.value);
            const tibiaLength = parseFloat(tibiaSlider.value);

            skeleton.tibia.scale.y = tibiaLength;
            skeleton.tibia.position.y = tibiaLength / 2;
            skeleton.knee.position.y = tibiaLength;
            skeleton.kneeJoint.position.y = tibiaLength;

            skeleton.femur.scale.y = femurLength;
            skeleton.femur.position.y = femurLength / 2;
            skeleton.hip.position.y = femurLength;
            skeleton.hipJoint.position.y = femurLength;

            skeleton.torso.scale.y = torsoLength;
            skeleton.torso.position.y = torsoLength / 2;
            skeleton.head.position.y = torsoLength + HEAD_RADIUS;

            skeleton.foot.position.set(FOOT_FORWARD, -JOINT_RADIUS, 0);

            torsoVal.textContent = torsoLength.toFixed(2);
            femurVal.textContent = femurLength.toFixed(2);
            tibiaVal.textContent = tibiaLength.toFixed(2);
            updateBarMarkerPosition();
            calibrateHipBase();

            updateAnimation();
        }

        function updateAnimation() {
            const t = parseFloat(animSlider.value);

            const ease = (value, power) => Math.pow(THREE.MathUtils.clamp(value, 0, 1), power);

            const torsoScale = parseFloat(torsoSlider.value);
            const easingScale = THREE.MathUtils.lerp(1.25, 0.85, THREE.MathUtils.clamp((torsoScale - 0.8) / 0.4, 0, 1));
            const ankleAngle = THREE.MathUtils.lerp(
                squatStart.ankleFlex,
                squatEnd.ankleFlex,
                ease(t, 1.15 * easingScale)
            );
            let kneeFlex = THREE.MathUtils.lerp(
                squatStart.kneeFlex,
                squatEnd.kneeFlex,
                ease(t, 1.35 * easingScale)
            );
            const alignFactorRaw = THREE.MathUtils.smoothstep(t, ALIGN_START_RATIO, 1);
            const alignPower = 1.4 * easingScale;
            const alignFactor = Math.pow(alignFactorRaw, alignPower);
            const depthFactorRaw = THREE.MathUtils.smoothstep(t, DEPTH_START_RATIO, 1);
            const depthFactor = Math.pow(depthFactorRaw, 1.5 * easingScale);
            const hipBase = THREE.MathUtils.lerp(
                squatStart.hipFlex,
                squatEnd.hipFlex,
                ease(t, 1.6 * easingScale)
            );

            skeleton.ankleRotator.rotation.z = ankleAngle;

            let femurAngle = ankleAngle - kneeFlex;
            skeleton.femurGroup.rotation.z = femurAngle;

            // Initial hip guess uses calibrated offset for solver stability
            let hipSolve = THREE.MathUtils.clamp(hipBase + hipBaseOffset, HIP_MIN, HIP_MAX);
            skeleton.hip.rotation.z = hipSolve;

            // Adjust knee flexion until hip drops below knee by DEPTH_MARGIN
            if (depthFactor > 0) {
                const MAX_KNEE_ITER = 8;
                const BASE_KNEE_STEP = THREE.MathUtils.degToRad(2.5);
                const kneeStep = BASE_KNEE_STEP * depthFactor;
                if (kneeStep > 0) {
                    for (let i = 0; i < MAX_KNEE_ITER; i++) {
                        skeleton.ankle.updateWorldMatrix(true, false);
                        skeleton.hipJoint.getWorldPosition(tempVec1);
                        skeleton.kneeJoint.getWorldPosition(tempVec2);

                        if (tempVec1.y <= tempVec2.y - DEPTH_MARGIN) {
                            break;
                        }

                        kneeFlex -= kneeStep;
                        femurAngle = ankleAngle - kneeFlex;
                        skeleton.femurGroup.rotation.z = femurAngle;
                    }
                }
            }

            skeleton.femurGroup.rotation.z = femurAngle;

            // Keep feet planted each frame
            skeleton.ankle.position.x = 0;
            skeleton.foot.position.x = FOOT_FORWARD;

            // Fully solve for hip rotation that keeps the bar marker over midfoot
            let hipAligned = hipSolve;
            const MAX_ITER = 14;
            const MAX_DELTA = 0.12; // ~6.9°
            for (let i = 0; i < MAX_ITER; i++) {
                skeleton.hip.rotation.z = hipAligned;
                skeleton.ankle.updateWorldMatrix(true, false);
                skeleton.barMarker.getWorldPosition(tempVec1);
                skeleton.hip.getWorldPosition(tempVec2);
                skeleton.foot.getWorldPosition(tempVec3);

                const targetX = tempVec3.x;
                const error = targetX - tempVec1.x;
                if (Math.abs(error) < 5e-5) break;

                const relative = tempVec1.clone().sub(tempVec2);
                const derivative = -relative.y;
                if (Math.abs(derivative) < 1e-4) break;

                let delta = error / derivative;
                if (!Number.isFinite(delta)) break;
                delta = THREE.MathUtils.clamp(delta, -MAX_DELTA, MAX_DELTA);
                hipAligned = THREE.MathUtils.clamp(hipAligned + delta, HIP_MIN, HIP_MAX);
            }

            const swingLimitBase = THREE.MathUtils.degToRad(20 + 40 * alignFactor);
            const swingLimit = swingLimitBase * torsoScale;
            hipAligned = THREE.MathUtils.clamp(hipAligned, hipSolve - swingLimit, hipSolve + swingLimit);

            // Blend toward the aligned solution to keep the descent smooth
            const alignWeight = THREE.MathUtils.lerp(START_ALIGN_WEIGHT, START_ALIGN_WEIGHT * 0.45, THREE.MathUtils.clamp(1 - torsoScale, 0, 1));
            const hipBaseBlended = THREE.MathUtils.clamp(
                hipBase + hipBaseOffset * alignWeight,
                HIP_MIN,
                HIP_MAX
            );
            let finalHip = THREE.MathUtils.clamp(
                THREE.MathUtils.lerp(hipBaseBlended, hipAligned, alignFactor),
                HIP_MIN,
                HIP_MAX
            );

            if (previousAnimValue !== null && previousHipAngle !== null) {
                if (t >= previousAnimValue) {
                    finalHip = Math.min(finalHip, previousHipAngle);
                } else {
                    finalHip = Math.max(finalHip, previousHipAngle);
                }
                finalHip = THREE.MathUtils.clamp(finalHip, HIP_MIN, HIP_MAX);
            }

            skeleton.hip.rotation.z = finalHip;

            skeleton.ankle.updateWorldMatrix(true, false);

            const hipDeg = THREE.MathUtils.radToDeg(finalHip);
            const kneeDeg = Math.abs(THREE.MathUtils.radToDeg(kneeFlex));
            const ankleDeg = Math.abs(THREE.MathUtils.radToDeg(ankleAngle));

            readoutHip.textContent = `${hipDeg.toFixed(1)}°`;
            readoutKnee.textContent = `${kneeDeg.toFixed(1)}°`;
            readoutAnkle.textContent = `${ankleDeg.toFixed(1)}°`;

            previousAnimValue = t;
            previousHipAngle = finalHip;
        }

        function onWindowResize() {
            const w = container.clientWidth;
            const h = container.clientHeight;

            renderer.setSize(w, h);

            const aspect = w / h;
            const viewSize = 6;
            camera.left = -viewSize * aspect / 2;
            camera.right = viewSize * aspect / 2;
            camera.top = viewSize / 2;
            camera.bottom = -viewSize / 2;
            camera.updateProjectionMatrix();
        }

        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }

        init();
    </script>
</body>
</html>