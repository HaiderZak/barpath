<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lifting Biomechanics Simulator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #111827; /* gray-900 */
            color: #f3f4f6; /* gray-100 */
            overscroll-behavior: none;
        }
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap');
        
        #canvas-container {
            width: 100%;
            height: 100%;
            position: relative;
        }
        canvas {
            display: block;
        }
        
        /* Custom slider styles */
        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 8px;
            border-radius: 4px;
            background: #374151; /* gray-700 */
            outline: none;
            opacity: 0.7;
            transition: opacity .2s;
        }
        input[type="range"]:hover {
            opacity: 1;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #3b82f6; /* blue-500 */
            cursor: pointer;
        }
        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #3b82f6; /* blue-500 */
            cursor: pointer;
        }
        
        #readouts {
            position: absolute;
            top: 20px;
            right: 20px;
            background-color: rgba(17, 24, 39, 0.8); /* gray-900 with opacity */
            padding: 16px;
            border-radius: 8px;
            border: 1px solid #374151; /* gray-700 */
            font-family: 'Courier New', Courier, monospace;
        }
    </style>
</head>
<body class="w-full h-screen m-0 p-0 flex overflow-hidden">

    <!-- CONTROLS SIDEBAR -->
    <div class="w-full max-w-xs p-6 bg-gray-800 h-screen overflow-y-auto shadow-xl">
        <h1 class="text-2xl font-bold mb-6 text-white">Lift Simulator</h1>
        
        <div class="space-y-6">
            <!-- Animation Controls -->
            <div>
                <h2 class="text-sm font-semibold text-blue-400 mb-3">ANIMATION</h2>
                <label for="animation-slider" class="text-sm text-gray-300 block mb-1">Lift Progress (0% to 100%)</label>
                <div class="flex items-center space-x-2">
                    <span class="text-xs text-gray-400">Up</span>
                    <input id="animation-slider" type="range" min="0" max="1" step="0.01" value="0">
                    <span class="text-xs text-gray-400">Down</span>
                </div>
            </div>

            <!-- Anthropometrics -->
            <div>
                <h2 class="text-sm font-semibold text-blue-400 mb-3">ANTHROPOMETRICS</h2>
                <div class="space-y-4">
                    <div>
                        <label for="torso-slider" class="text-sm text-gray-300 block mb-1">Torso Length: <span id="torso-val" class="font-medium text-white">1.0</span></label>
                        <input id="torso-slider" type="range" min="0.8" max="1.25" step="0.01" value="1.0">
                    </div>
                    <div>
                        <label for="femur-slider" class="text-sm text-gray-300 block mb-1">Femur Length: <span id="femur-val" class="font-medium text-white">1.0</span></label>
                        <input id="femur-slider" type="range" min="0.8" max="1.25" step="0.01" value="1.0">
                    </div>
                    <div>
                        <label for="tibia-slider" class="text-sm text-gray-300 block mb-1">Tibia Length: <span id="tibia-val" class="font-medium text-white">1.0</span></label>
                        <input id="tibia-slider" type="range" min="0.8" max="1.25" step="0.01" value="1.0">
                    </div>
                </div>
            </div>

            <!-- Bar Marker Placement -->
            <div>
                <h2 class="text-sm font-semibold text-blue-400 mb-3">BAR MARKER</h2>
                <label for="bar-slider" class="text-sm text-gray-300 block mb-1">Marker Height: <span id="bar-val" class="font-medium text-white">0.50</span></label>
                <input id="bar-slider" type="range" min="0" max="1" step="0.01" value="0.5">
                <div class="grid grid-cols-3 text-xs text-gray-400 w-full">
                    <span class="text-left">French Low bar</span>
                    <span class="text-center">Low bar</span>
                    <span class="text-right">High bar</span>
                </div>
            </div>

            <!-- Utility -->
            <div class="pt-4 border-t border-gray-700">
                <button id="reset-button" class="w-full px-4 py-2 bg-blue-500 hover:bg-blue-600 text-white text-sm font-semibold rounded-md transition-colors">Reset to Defaults</button>
            </div>

        </div>
    </div>

    <!-- 3D CANVAS -->
    <div id="canvas-container" class="flex-1">
        <!-- JS-controlled readout -->
        <div id="readouts" class="text-sm text-gray-300 space-y-2">
            <div>Hip Angle: <span id="hip-angle" class="font-bold text-white">0.0°</span></div>
            <div>Knee Angle: <span id="knee-angle" class="font-bold text-white">0.0°</span></div>
            <div>Ankle Angle: <span id="ankle-angle" class="font-bold text-white">0.0°</span></div>
        </div>
    </div>

    <!-- THREE.JS SCRIPT -->
    <script type="module">
        import * as THREE from 'https://cdn.skypack.dev/three@0.132.2';
        import { OrbitControls } from 'https://cdn.skypack.dev/three@0.132.2/examples/jsm/controls/OrbitControls.js';

        const LIMB_WIDTH = 0.07;
        const JOINT_RADIUS = 0.07;
    const HEAD_RADIUS = 0.2;
    const HEAD_VERTICAL_OFFSET = 0.12;
    const FOOT_LENGTH = 0.5;
    const FOOT_FORWARD = 0.18;
    const DEPTH_MARGIN = 0.02;
    const DEPTH_START_RATIO = 0.6;
    const ALIGN_START_RATIO = 0.1;
    const HIP_MIN = THREE.MathUtils.degToRad(-160);
    const HIP_MAX = THREE.MathUtils.degToRad(45);
    const START_ALIGN_WEIGHT = 0.25;
    const LEG_SPACING = 0.1;
    const PELVIS_HALF_DEPTH = LEG_SPACING * 2;
    const HIP_CENTER_OFFSET = PELVIS_HALF_DEPTH;
    const LEFT_LEG_OFFSET = PELVIS_HALF_DEPTH;
    const RIGHT_LEG_OFFSET = -PELVIS_HALF_DEPTH;
    const BAR_DEPTH_OFFSET = -0.12;
    const TORSO_HALF_DEPTH = (LIMB_WIDTH * 2.2) / 2;
    const SHOULDER_HALF_WIDTH = TORSO_HALF_DEPTH + 0.015;
    const SHOULDER_DEPTH_OFFSET = -TORSO_HALF_DEPTH - 0.008;
    const SHOULDER_HEIGHT_RATIO = 0.72;
    const ARM_RADIUS = LIMB_WIDTH * 0.6;
    const HAND_RADIUS = JOINT_RADIUS * 0.6;
    const HAND_GRIP_DROP = 0.08;
    const ARM_MIN_GRIP = SHOULDER_HALF_WIDTH + 0.12;
    const ARM_MAX_GRIP = SHOULDER_HALF_WIDTH + 0.36;
    const UPPER_ARM_LENGTH = 0.36;
    const FOREARM_LENGTH = 0.44;
    const FEMUR_BASE_SCALE = 0.7;
    const TIBIA_BASE_SCALE = 0.7;
    const HUMERUS_FLARE_ANGLE = THREE.MathUtils.degToRad(12);
    const DEFAULTS = Object.freeze({
        animation: 0,
        torso: 1.0,
        femur: 1.0,
        tibia: 1.0,
        bar: 0.5
    });

    let scene, camera, renderer;
    let controls;
    const skeleton = {};
    const tempVec1 = new THREE.Vector3();
    const tempVec2 = new THREE.Vector3();
    const tempVec3 = new THREE.Vector3();
    const tempVec4 = new THREE.Vector3();
    const tempVec5 = new THREE.Vector3();
    const tempVec6 = new THREE.Vector3();
    const tempQuat = new THREE.Quaternion();
    const tempQuat2 = new THREE.Quaternion();
    const upVector = new THREE.Vector3(0, 1, 0);
    let hipBaseOffset = 0;
    let previousAnimValue = null;
    let previousHipAngle = null;

        const container = document.getElementById('canvas-container');
        const readoutHip = document.getElementById('hip-angle');
        const readoutKnee = document.getElementById('knee-angle');
        const readoutAnkle = document.getElementById('ankle-angle');

        const animSlider = document.getElementById('animation-slider');
        const torsoSlider = document.getElementById('torso-slider');
        const femurSlider = document.getElementById('femur-slider');
        const tibiaSlider = document.getElementById('tibia-slider');
        const barSlider = document.getElementById('bar-slider');
    const resetButton = document.getElementById('reset-button');

        const torsoVal = document.getElementById('torso-val');
        const femurVal = document.getElementById('femur-val');
        const tibiaVal = document.getElementById('tibia-val');
    const barVal = document.getElementById('bar-val');

        const squatStart = {
            hipFlex: THREE.MathUtils.degToRad(0),
            kneeFlex: THREE.MathUtils.degToRad(0),
            ankleFlex: THREE.MathUtils.degToRad(0)
        };

        const squatEnd = {
            hipFlex: THREE.MathUtils.degToRad(-150),  // deeper torso lean over femur
            kneeFlex: THREE.MathUtils.degToRad(-170), // additional knee flexion to drop hip
            ankleFlex: THREE.MathUtils.degToRad(-42)  // extra dorsiflexion to keep balance
        };

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x111827);

            const aspect = container.clientWidth / container.clientHeight;
            const viewSize = 6;
            camera = new THREE.OrthographicCamera(
                -viewSize * aspect / 2,
                viewSize * aspect / 2,
                viewSize / 2,
                -viewSize / 2,
                0.1,
                100
            );
            camera.position.set(5, 3, 8);
            camera.lookAt(0, 2.5, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            container.appendChild(renderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.08;
            controls.enablePan = false;
            controls.rotateSpeed = 0.6;

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.9);
            directionalLight.position.set(5, 8, 10);
            scene.add(directionalLight);

            const floorGeo = new THREE.BoxGeometry(10, 0.1, 10);
            const floorMat = new THREE.MeshStandardMaterial({ color: 0x374151 });
            const floor = new THREE.Mesh(floorGeo, floorMat);
            floor.position.set(0, -0.05, 0);
            scene.add(floor);

            createSkeleton();
            controls.target.set(0, 1.2, 0);
            controls.update();
            controls.saveState();
            calibrateHipBase();
            addEventListeners();
            updateModelProportions();
            animate();
        }

        function createSkeleton() {
            const limbMaterial = new THREE.MeshStandardMaterial({ color: 0xf3f4f6 });
            const jointMaterial = new THREE.MeshStandardMaterial({ color: 0x3b82f6 });

            const footGeo = new THREE.BoxGeometry(FOOT_LENGTH, LIMB_WIDTH, LIMB_WIDTH);
            const tibiaGeo = new THREE.BoxGeometry(LIMB_WIDTH, 1, LIMB_WIDTH);
            const femurGeo = new THREE.BoxGeometry(LIMB_WIDTH, 1, LIMB_WIDTH);
            const torsoGeo = new THREE.BoxGeometry(LIMB_WIDTH * 2.2, 1.3, LIMB_WIDTH * 2.2);
            const headGeo = new THREE.SphereGeometry(HEAD_RADIUS, 16, 16);
            const jointGeo = new THREE.SphereGeometry(JOINT_RADIUS, 16, 16);
            const handGeo = new THREE.SphereGeometry(HAND_RADIUS, 16, 16);
            const armGeo = new THREE.CylinderGeometry(ARM_RADIUS, ARM_RADIUS, 1, 14);
            const pelvisGeo = new THREE.BoxGeometry(LIMB_WIDTH * 3, 0.35, LEG_SPACING * 4);
            const barGeo = new THREE.CylinderGeometry(0.012, 0.012, 1.9, 24);
            const plateGeo = new THREE.CylinderGeometry(0.22, 0.22, 0.045, 48);

            skeleton.foot = new THREE.Mesh(footGeo, limbMaterial);
            skeleton.tibia = new THREE.Mesh(tibiaGeo, limbMaterial);
            skeleton.femur = new THREE.Mesh(femurGeo, limbMaterial);
            skeleton.torso = new THREE.Mesh(torsoGeo, limbMaterial);
            skeleton.head = new THREE.Mesh(headGeo, limbMaterial);
            skeleton.ankleJoint = new THREE.Mesh(jointGeo, jointMaterial);
            skeleton.kneeJoint = new THREE.Mesh(jointGeo, jointMaterial);
            skeleton.hipJoint = new THREE.Mesh(jointGeo, jointMaterial);

            skeleton.ankle = new THREE.Group();
            skeleton.ankleRotator = new THREE.Group();
            skeleton.knee = new THREE.Group();
            skeleton.femurGroup = new THREE.Group();
            skeleton.hip = new THREE.Group();

            scene.add(skeleton.ankle);

            skeleton.ankle.add(skeleton.foot);
            skeleton.ankle.add(skeleton.ankleJoint);
            skeleton.ankle.add(skeleton.ankleRotator);

            skeleton.ankleRotator.add(skeleton.tibia);
            skeleton.ankleRotator.add(skeleton.kneeJoint);
            skeleton.ankleRotator.add(skeleton.knee);

            skeleton.knee.add(skeleton.femurGroup);

            skeleton.femurGroup.add(skeleton.femur);
            skeleton.femurGroup.add(skeleton.hipJoint);
            skeleton.femurGroup.add(skeleton.hip);

            skeleton.hip.add(skeleton.torso);
            skeleton.hip.add(skeleton.head);

            skeleton.ankle.position.set(0, JOINT_RADIUS + LIMB_WIDTH / 2, RIGHT_LEG_OFFSET);
            skeleton.foot.position.set(FOOT_FORWARD, -JOINT_RADIUS, 0);
            skeleton.ankleJoint.position.set(0, 0, 0);

            skeleton.tibia.position.set(0, 0.5, 0);
            skeleton.knee.position.set(0, 1, 0);
            skeleton.kneeJoint.position.set(0, 1, 0);

            skeleton.femur.position.set(0, 0.5, 0);
            skeleton.hip.position.set(0, 1, 0);
            skeleton.hipJoint.position.set(0, 1, 0);

            skeleton.torso.position.set(0, 0.65, HIP_CENTER_OFFSET);
            skeleton.head.position.set(0, 1.15 + HEAD_VERTICAL_OFFSET, HIP_CENTER_OFFSET);

            skeleton.pelvis = new THREE.Mesh(pelvisGeo, limbMaterial);
            skeleton.pelvis.position.set(0, 0.18, HIP_CENTER_OFFSET);
            skeleton.hip.add(skeleton.pelvis);

            skeleton.rightShoulderAnchor = new THREE.Group();
            skeleton.leftShoulderAnchor = new THREE.Group();
            skeleton.rightShoulderJoint = new THREE.Mesh(jointGeo, jointMaterial);
            skeleton.leftShoulderJoint = new THREE.Mesh(jointGeo, jointMaterial);
            skeleton.rightShoulderAnchor.add(skeleton.rightShoulderJoint);
            skeleton.leftShoulderAnchor.add(skeleton.leftShoulderJoint);
            skeleton.torso.add(skeleton.rightShoulderAnchor);
            skeleton.torso.add(skeleton.leftShoulderAnchor);
            const initialTorsoLength = DEFAULTS.torso;
            const initialTorsoHalfHeight = 0.65 * initialTorsoLength;
            const initialShoulderY = THREE.MathUtils.lerp(-initialTorsoHalfHeight, initialTorsoHalfHeight, SHOULDER_HEIGHT_RATIO);
            skeleton.rightShoulderAnchor.position.set(SHOULDER_DEPTH_OFFSET, initialShoulderY, SHOULDER_HALF_WIDTH);
            skeleton.leftShoulderAnchor.position.set(SHOULDER_DEPTH_OFFSET, initialShoulderY, -SHOULDER_HALF_WIDTH);

            skeleton.rightUpperArm = new THREE.Mesh(armGeo, limbMaterial);
            skeleton.leftUpperArm = new THREE.Mesh(armGeo, limbMaterial);
            skeleton.rightForearm = new THREE.Mesh(armGeo, limbMaterial);
            skeleton.leftForearm = new THREE.Mesh(armGeo, limbMaterial);
            [
                skeleton.rightUpperArm,
                skeleton.leftUpperArm
            ].forEach(upper => {
                upper.scale.y = UPPER_ARM_LENGTH;
            });
            [
                skeleton.rightForearm,
                skeleton.leftForearm
            ].forEach(lower => {
                lower.scale.y = FOREARM_LENGTH;
            });
            scene.add(skeleton.rightUpperArm);
            scene.add(skeleton.leftUpperArm);
            scene.add(skeleton.rightForearm);
            scene.add(skeleton.leftForearm);

            skeleton.rightElbow = new THREE.Group();
            skeleton.leftElbow = new THREE.Group();
            skeleton.rightElbowJoint = new THREE.Mesh(jointGeo, jointMaterial);
            skeleton.leftElbowJoint = new THREE.Mesh(jointGeo, jointMaterial);
            skeleton.rightElbow.add(skeleton.rightElbowJoint);
            skeleton.leftElbow.add(skeleton.leftElbowJoint);
            scene.add(skeleton.rightElbow);
            scene.add(skeleton.leftElbow);

            skeleton.leftAnkle = new THREE.Group();
            skeleton.leftAnkleRotator = new THREE.Group();
            skeleton.leftKnee = new THREE.Group();
            skeleton.leftFemurGroup = new THREE.Group();
            skeleton.leftHip = new THREE.Group();

            skeleton.leftFoot = new THREE.Mesh(footGeo, limbMaterial);
            skeleton.leftAnkleJoint = new THREE.Mesh(jointGeo, jointMaterial);
            skeleton.leftTibia = new THREE.Mesh(tibiaGeo, limbMaterial);
            skeleton.leftKneeJoint = new THREE.Mesh(jointGeo, jointMaterial);
            skeleton.leftFemur = new THREE.Mesh(femurGeo, limbMaterial);
            skeleton.leftHipJoint = new THREE.Mesh(jointGeo, jointMaterial);

            scene.add(skeleton.leftAnkle);

            skeleton.leftAnkle.add(skeleton.leftFoot);
            skeleton.leftAnkle.add(skeleton.leftAnkleJoint);
            skeleton.leftAnkle.add(skeleton.leftAnkleRotator);

            skeleton.leftAnkleRotator.add(skeleton.leftTibia);
            skeleton.leftAnkleRotator.add(skeleton.leftKneeJoint);
            skeleton.leftAnkleRotator.add(skeleton.leftKnee);

            skeleton.leftKnee.add(skeleton.leftFemurGroup);

            skeleton.leftFemurGroup.add(skeleton.leftFemur);
            skeleton.leftFemurGroup.add(skeleton.leftHipJoint);
            skeleton.leftFemurGroup.add(skeleton.leftHip);

            skeleton.leftAnkle.position.set(0, JOINT_RADIUS + LIMB_WIDTH / 2, LEFT_LEG_OFFSET);
            skeleton.leftFoot.position.set(FOOT_FORWARD, -JOINT_RADIUS, 0);
            skeleton.leftAnkleJoint.position.set(0, 0, 0);

            skeleton.leftTibia.position.set(0, 0.5, 0);
            skeleton.leftKnee.position.set(0, 1, 0);
            skeleton.leftKneeJoint.position.set(0, 1, 0);

            skeleton.leftFemur.position.set(0, 0.5, 0);
            skeleton.leftHip.position.set(0, 1, 0);
            skeleton.leftHipJoint.position.set(0, 1, 0);

            const barMaterial = new THREE.MeshStandardMaterial({ color: 0xd1d5db, metalness: 0.75, roughness: 0.35 });
            const plateMaterial = new THREE.MeshStandardMaterial({ color: 0xef4444, metalness: 0.6, roughness: 0.4, emissive: 0x7f1d1d, emissiveIntensity: 0.25 });
            const greenPlateMaterial = new THREE.MeshStandardMaterial({ color: 0x10b981, metalness: 0.6, roughness: 0.4, emissive: 0x064e3b, emissiveIntensity: 0.2 });
            skeleton.barbell = new THREE.Group();
            const barMesh = new THREE.Mesh(barGeo, barMaterial);
            barMesh.rotation.x = Math.PI / 2;
            skeleton.barbell.add(barMesh);

            const redPlatesPerSide = 4;
            const redPlateBaseOffset = 0.78;
            const redPlateSpacing = 0.07;
            for (let i = 0; i < redPlatesPerSide; i++) {
                const offset = redPlateBaseOffset - i * redPlateSpacing;
                [offset, -offset].forEach(sideOffset => {
                    const plate = new THREE.Mesh(plateGeo, plateMaterial);
                    plate.rotation.x = Math.PI / 2;
                    plate.position.z = sideOffset;
                    skeleton.barbell.add(plate);
                });
            }

            const greenPlateRadius = 0.18;
            const greenPlateThickness = 0.04;
            const greenPlateGeo = new THREE.CylinderGeometry(greenPlateRadius, greenPlateRadius, greenPlateThickness, 48);
            const greenPlateOffset = redPlateBaseOffset + redPlateSpacing;
            [greenPlateOffset, -greenPlateOffset].forEach(sideOffset => {
                const plate = new THREE.Mesh(greenPlateGeo, greenPlateMaterial);
                plate.rotation.x = Math.PI / 2;
                plate.position.z = sideOffset;
                skeleton.barbell.add(plate);
            });

            skeleton.torso.add(skeleton.barbell);
            skeleton.barbell.position.set(BAR_DEPTH_OFFSET, 0.35, 0);

            skeleton.rightHandGroup = new THREE.Group();
            skeleton.leftHandGroup = new THREE.Group();
            skeleton.barbell.add(skeleton.rightHandGroup);
            skeleton.barbell.add(skeleton.leftHandGroup);
            skeleton.rightHandGroup.position.set(0, -HAND_GRIP_DROP, ARM_MAX_GRIP);
            skeleton.leftHandGroup.position.set(0, -HAND_GRIP_DROP, -ARM_MAX_GRIP);

            skeleton.rightHand = new THREE.Mesh(handGeo, limbMaterial);
            skeleton.leftHand = new THREE.Mesh(handGeo, limbMaterial);
            skeleton.rightHandGroup.add(skeleton.rightHand);
            skeleton.leftHandGroup.add(skeleton.leftHand);
        }

        function addEventListeners() {
            window.addEventListener('resize', onWindowResize);

            [torsoSlider, femurSlider, tibiaSlider].forEach(slider => {
                slider.addEventListener('input', updateModelProportions);
            });

            animSlider.addEventListener('input', updateAnimation);

            if (resetButton) {
                resetButton.addEventListener('click', resetToDefaults);
            }

            torsoSlider.addEventListener('input', (e) => torsoVal.textContent = parseFloat(e.target.value).toFixed(2));
            femurSlider.addEventListener('input', (e) => femurVal.textContent = parseFloat(e.target.value).toFixed(2));
            tibiaSlider.addEventListener('input', (e) => tibiaVal.textContent = parseFloat(e.target.value).toFixed(2));
            barSlider.addEventListener('input', () => {
                updateBarbellHeight();
                calibrateHipBase();
                updateAnimation();
            });
        }

        function updateBarbellHeight() {
            const placement = parseFloat(barSlider.value);
            const normalizedY = THREE.MathUtils.lerp(-0.15, 0.4, placement);
            if (skeleton.barbell) {
                skeleton.barbell.position.y = normalizedY;
                skeleton.barbell.position.x = BAR_DEPTH_OFFSET;
                updateArmAttachments();
            }
            barVal.textContent = placement.toFixed(2);
        }

        function calibrateHipBase() {
            if (!skeleton.hip) return;

            skeleton.ankleRotator.rotation.z = squatStart.ankleFlex;
            skeleton.femurGroup.rotation.z = squatStart.ankleFlex - squatStart.kneeFlex;
            skeleton.hip.rotation.z = 0;

            if (skeleton.leftAnkleRotator) {
                skeleton.leftAnkleRotator.rotation.z = squatStart.ankleFlex;
                skeleton.leftFemurGroup.rotation.z = squatStart.ankleFlex - squatStart.kneeFlex;
                skeleton.leftHip.rotation.z = 0;
            }

            skeleton.ankle.position.x = 0;
            skeleton.foot.position.x = FOOT_FORWARD;
            skeleton.ankle.position.z = RIGHT_LEG_OFFSET;
            if (skeleton.leftAnkle) {
                skeleton.leftAnkle.position.x = 0;
                skeleton.leftFoot.position.x = FOOT_FORWARD;
                skeleton.leftAnkle.position.z = LEFT_LEG_OFFSET;
            }

            const MAX_ITER = 12;
            const MAX_DELTA = 0.12;
            let hipAngle = 0;

            for (let i = 0; i < MAX_ITER; i++) {
                skeleton.ankle.updateWorldMatrix(true, false);
                if (!skeleton.barbell) break;
                skeleton.barbell.updateWorldMatrix(true, false);
                tempVec1.set(0, 0, 0);
                skeleton.barbell.localToWorld(tempVec1);
                skeleton.hip.getWorldPosition(tempVec2);
                skeleton.foot.getWorldPosition(tempVec3);

                const error = tempVec3.x - tempVec1.x;
                if (Math.abs(error) < 5e-5) break;

                const relative = tempVec1.clone().sub(tempVec2);
                const derivative = -relative.y;
                if (Math.abs(derivative) < 1e-4) break;

                let delta = error / derivative;
                if (!Number.isFinite(delta)) break;
                delta = THREE.MathUtils.clamp(delta, -MAX_DELTA, MAX_DELTA);
                hipAngle = THREE.MathUtils.clamp(hipAngle + delta, HIP_MIN, HIP_MAX);
                skeleton.hip.rotation.z = hipAngle;
            }

            hipBaseOffset = hipAngle;
            skeleton.hip.rotation.z = 0;
            previousAnimValue = null;
            previousHipAngle = null;
        }

        function resetToDefaults() {
            animSlider.value = DEFAULTS.animation.toString();
            torsoSlider.value = DEFAULTS.torso.toString();
            femurSlider.value = DEFAULTS.femur.toString();
            tibiaSlider.value = DEFAULTS.tibia.toString();
            barSlider.value = DEFAULTS.bar.toString();

            torsoVal.textContent = DEFAULTS.torso.toFixed(2);
            femurVal.textContent = DEFAULTS.femur.toFixed(2);
            tibiaVal.textContent = DEFAULTS.tibia.toFixed(2);
            barVal.textContent = DEFAULTS.bar.toFixed(2);

            updateBarbellHeight();
            updateModelProportions();

            if (controls) {
                controls.reset();
            }
        }

        function updateModelProportions() {
            const torsoLength = parseFloat(torsoSlider.value);
            const femurFactor = parseFloat(femurSlider.value);
            const tibiaFactor = parseFloat(tibiaSlider.value);
            const femurLength = femurFactor * FEMUR_BASE_SCALE;
            const tibiaLength = tibiaFactor * TIBIA_BASE_SCALE;

            skeleton.tibia.scale.y = tibiaLength;
            skeleton.tibia.position.y = tibiaLength / 2;
            skeleton.knee.position.y = tibiaLength;
            skeleton.kneeJoint.position.y = tibiaLength;

            if (skeleton.leftTibia) {
                skeleton.leftTibia.scale.y = tibiaLength;
                skeleton.leftTibia.position.y = tibiaLength / 2;
                skeleton.leftKnee.position.y = tibiaLength;
                skeleton.leftKneeJoint.position.y = tibiaLength;
            }

            skeleton.femur.scale.y = femurLength;
            skeleton.femur.position.y = femurLength / 2;
            skeleton.hip.position.y = femurLength;
            skeleton.hipJoint.position.y = femurLength;

            if (skeleton.leftFemur) {
                skeleton.leftFemur.scale.y = femurLength;
                skeleton.leftFemur.position.y = femurLength / 2;
                skeleton.leftHip.position.y = femurLength;
                skeleton.leftHipJoint.position.y = femurLength;
            }

            skeleton.torso.scale.y = torsoLength;
            skeleton.torso.position.y = torsoLength * 0.5 + 0.15;
            skeleton.torso.position.z = HIP_CENTER_OFFSET;
            skeleton.head.position.y = torsoLength * 1.02 + HEAD_RADIUS * 0.4 + HEAD_VERTICAL_OFFSET;
            skeleton.head.position.z = HIP_CENTER_OFFSET;
            if (skeleton.pelvis) {
                skeleton.pelvis.position.z = HIP_CENTER_OFFSET;
            }

            if (skeleton.rightShoulderAnchor && skeleton.leftShoulderAnchor) {
                const torsoHalfHeight = 0.65 * torsoLength;
                const shoulderLocalY = THREE.MathUtils.lerp(-torsoHalfHeight, torsoHalfHeight, SHOULDER_HEIGHT_RATIO);
                skeleton.rightShoulderAnchor.position.set(SHOULDER_DEPTH_OFFSET, shoulderLocalY, SHOULDER_HALF_WIDTH);
                skeleton.leftShoulderAnchor.position.set(SHOULDER_DEPTH_OFFSET, shoulderLocalY, -SHOULDER_HALF_WIDTH);
            }

            skeleton.foot.position.set(FOOT_FORWARD, -JOINT_RADIUS, 0);
            if (skeleton.leftFoot) {
                skeleton.leftFoot.position.set(FOOT_FORWARD, -JOINT_RADIUS, 0);
            }

            skeleton.ankle.position.z = RIGHT_LEG_OFFSET;
            if (skeleton.leftAnkle) {
                skeleton.leftAnkle.position.z = LEFT_LEG_OFFSET;
            }

            torsoVal.textContent = torsoLength.toFixed(2);
            femurVal.textContent = femurFactor.toFixed(2);
            tibiaVal.textContent = tibiaFactor.toFixed(2);
            updateBarbellHeight();
            calibrateHipBase();
            updateArmAttachments();

            updateAnimation();
        }

        function alignSegmentBetween(segmentMesh, startObject, endObject, segmentLength) {
            if (!segmentMesh || !startObject || !endObject) return;

            startObject.updateWorldMatrix(true, false);
            endObject.updateWorldMatrix(true, false);
            startObject.getWorldPosition(tempVec1);
            endObject.getWorldPosition(tempVec2);

            tempVec4.copy(tempVec2).sub(tempVec1);
            const distance = tempVec4.length();
            if (distance < 1e-4) {
                segmentMesh.visible = false;
                return;
            }

            segmentMesh.visible = true;
            const direction = tempVec4.normalize();
            tempQuat.setFromUnitVectors(upVector, direction);
            segmentMesh.setRotationFromQuaternion(tempQuat);

            tempVec3.copy(tempVec1).add(tempVec2).multiplyScalar(0.5);
            segmentMesh.position.copy(tempVec3);
            segmentMesh.scale.set(1, segmentLength, 1);
        }

        function updateArmAttachments() {
            if (!skeleton.barbell || !skeleton.rightHandGroup || !skeleton.leftHandGroup) return;

            const placementRaw = barSlider ? parseFloat(barSlider.value) : DEFAULTS.bar;
            const placement = Number.isFinite(placementRaw) ? THREE.MathUtils.clamp(placementRaw, 0, 1) : DEFAULTS.bar;
            const baseGrip = THREE.MathUtils.lerp(ARM_MAX_GRIP, ARM_MIN_GRIP, placement);
            const minimumGrip = Math.max(SHOULDER_HALF_WIDTH + 0.02, ARM_MIN_GRIP);
            const gripHalfWidth = THREE.MathUtils.clamp(Math.max(baseGrip, minimumGrip), minimumGrip, ARM_MAX_GRIP);

            skeleton.rightHandGroup.position.set(0, -HAND_GRIP_DROP, gripHalfWidth);
            skeleton.leftHandGroup.position.set(0, -HAND_GRIP_DROP, -gripHalfWidth);

            skeleton.barbell.updateWorldMatrix(true, false);
            skeleton.rightHandGroup.updateWorldMatrix(true, false);
            skeleton.leftHandGroup.updateWorldMatrix(true, false);
            if (skeleton.torso) {
                skeleton.torso.updateWorldMatrix(true, false);
            }

            const updateSide = (isRight) => {
                const shoulderAnchor = isRight ? skeleton.rightShoulderAnchor : skeleton.leftShoulderAnchor;
                const handGroup = isRight ? skeleton.rightHandGroup : skeleton.leftHandGroup;
                const elbowGroup = isRight ? skeleton.rightElbow : skeleton.leftElbow;
                const upperArm = isRight ? skeleton.rightUpperArm : skeleton.leftUpperArm;
                const forearm = isRight ? skeleton.rightForearm : skeleton.leftForearm;

                if (!shoulderAnchor || !handGroup || !elbowGroup) return;

                shoulderAnchor.updateWorldMatrix(true, false);
                handGroup.updateWorldMatrix(true, false);

                const shoulderWorld = tempVec1;
                const handWorld = tempVec6;
                shoulderAnchor.getWorldPosition(shoulderWorld);
                handGroup.getWorldPosition(handWorld);

                const torsoQuat = tempQuat;
                if (skeleton.torso) {
                    skeleton.torso.getWorldQuaternion(torsoQuat);
                } else {
                    torsoQuat.identity();
                }

                const flareQuat = tempQuat2.setFromAxisAngle(tempVec4.set(1, 0, 0), isRight ? -HUMERUS_FLARE_ANGLE : HUMERUS_FLARE_ANGLE);
                const localDirection = tempVec3.set(0, -1, 0).applyQuaternion(flareQuat).normalize();
                const elbowOffset = tempVec4.copy(localDirection).applyQuaternion(torsoQuat).normalize().multiplyScalar(UPPER_ARM_LENGTH);
                const elbowWorld = tempVec5.copy(shoulderWorld).add(elbowOffset);

                elbowGroup.position.copy(elbowWorld);
                elbowGroup.updateMatrixWorld(true);

                if (upperArm) {
                    alignSegmentBetween(upperArm, shoulderAnchor, elbowGroup, UPPER_ARM_LENGTH);
                }

                if (forearm) {
                    const elbowWorldActual = tempVec2;
                    elbowGroup.getWorldPosition(elbowWorldActual);

                    const elbowToHand = tempVec3.copy(handWorld).sub(elbowWorldActual);
                    const forearmDistance = elbowToHand.length();
                    if (forearmDistance < 1e-5) {
                        forearm.visible = false;
                    } else {
                        forearm.visible = true;
                        elbowToHand.normalize();
                        tempQuat.setFromUnitVectors(upVector, elbowToHand);
                        forearm.setRotationFromQuaternion(tempQuat);
                        tempVec5.copy(elbowWorldActual).add(handWorld).multiplyScalar(0.5);
                        forearm.position.copy(tempVec5);
                        forearm.scale.set(1, forearmDistance, 1);
                    }
                }
            };

            updateSide(true);
            updateSide(false);
        }

        function updateAnimation() {
            const t = parseFloat(animSlider.value);

            const ease = (value, power) => Math.pow(THREE.MathUtils.clamp(value, 0, 1), power);

            const torsoScale = parseFloat(torsoSlider.value);
            const easingScale = THREE.MathUtils.lerp(1.25, 0.85, THREE.MathUtils.clamp((torsoScale - 0.8) / 0.4, 0, 1));
            const ankleAngle = THREE.MathUtils.lerp(
                squatStart.ankleFlex,
                squatEnd.ankleFlex,
                ease(t, 1.15 * easingScale)
            );
            let kneeFlex = THREE.MathUtils.lerp(
                squatStart.kneeFlex,
                squatEnd.kneeFlex,
                ease(t, 1.35 * easingScale)
            );
            const alignFactorRaw = THREE.MathUtils.smoothstep(t, ALIGN_START_RATIO, 1);
            const alignPower = 1.4 * easingScale;
            const alignFactor = Math.pow(alignFactorRaw, alignPower);
            const depthFactorRaw = THREE.MathUtils.smoothstep(t, DEPTH_START_RATIO, 1);
            const depthFactor = Math.pow(depthFactorRaw, 1.5 * easingScale);
            const hipBase = THREE.MathUtils.lerp(
                squatStart.hipFlex,
                squatEnd.hipFlex,
                ease(t, 1.6 * easingScale)
            );

            skeleton.ankleRotator.rotation.z = ankleAngle;
            if (skeleton.leftAnkleRotator) {
                skeleton.leftAnkleRotator.rotation.z = ankleAngle;
            }

            let femurAngle = ankleAngle - kneeFlex;
            skeleton.femurGroup.rotation.z = femurAngle;
            if (skeleton.leftFemurGroup) {
                skeleton.leftFemurGroup.rotation.z = femurAngle;
            }

            // Initial hip guess uses calibrated offset for solver stability
            let hipSolve = THREE.MathUtils.clamp(hipBase + hipBaseOffset, HIP_MIN, HIP_MAX);
            skeleton.hip.rotation.z = hipSolve;
            if (skeleton.leftHip) {
                skeleton.leftHip.rotation.z = hipSolve;
            }

            // Adjust knee flexion until hip drops below knee by DEPTH_MARGIN
            if (depthFactor > 0) {
                const MAX_KNEE_ITER = 8;
                const BASE_KNEE_STEP = THREE.MathUtils.degToRad(2.5);
                const kneeStep = BASE_KNEE_STEP * depthFactor;
                if (kneeStep > 0) {
                    for (let i = 0; i < MAX_KNEE_ITER; i++) {
                        skeleton.ankle.updateWorldMatrix(true, false);
                        skeleton.hipJoint.getWorldPosition(tempVec1);
                        skeleton.kneeJoint.getWorldPosition(tempVec2);

                        if (tempVec1.y <= tempVec2.y - DEPTH_MARGIN) {
                            break;
                        }

                        kneeFlex -= kneeStep;
                        femurAngle = ankleAngle - kneeFlex;
                        skeleton.femurGroup.rotation.z = femurAngle;
                        if (skeleton.leftFemurGroup) {
                            skeleton.leftFemurGroup.rotation.z = femurAngle;
                        }
                    }
                }
            }

            skeleton.femurGroup.rotation.z = femurAngle;
            if (skeleton.leftFemurGroup) {
                skeleton.leftFemurGroup.rotation.z = femurAngle;
            }

            // Keep feet planted each frame
            skeleton.ankle.position.x = 0;
            skeleton.ankle.position.z = RIGHT_LEG_OFFSET;
            skeleton.foot.position.x = FOOT_FORWARD;
            if (skeleton.leftAnkle) {
                skeleton.leftAnkle.position.x = 0;
                skeleton.leftAnkle.position.z = LEFT_LEG_OFFSET;
            }
            if (skeleton.leftFoot) {
                skeleton.leftFoot.position.x = FOOT_FORWARD;
            }

            // Fully solve for hip rotation that keeps the bar marker over midfoot
            let hipAligned = hipSolve;
            const MAX_ITER = 14;
            const MAX_DELTA = 0.12; // ~6.9°
            for (let i = 0; i < MAX_ITER; i++) {
                skeleton.hip.rotation.z = hipAligned;
                if (skeleton.leftHip) {
                    skeleton.leftHip.rotation.z = hipAligned;
                }
                skeleton.ankle.updateWorldMatrix(true, false);
                if (!skeleton.barbell) break;
                skeleton.barbell.updateWorldMatrix(true, false);
                tempVec1.set(0, 0, 0);
                skeleton.barbell.localToWorld(tempVec1);
                skeleton.hip.getWorldPosition(tempVec2);
                skeleton.foot.getWorldPosition(tempVec3);

                const targetX = tempVec3.x;
                const error = targetX - tempVec1.x;
                if (Math.abs(error) < 5e-5) break;

                const relative = tempVec1.clone().sub(tempVec2);
                const derivative = -relative.y;
                if (Math.abs(derivative) < 1e-4) break;

                let delta = error / derivative;
                if (!Number.isFinite(delta)) break;
                delta = THREE.MathUtils.clamp(delta, -MAX_DELTA, MAX_DELTA);
                hipAligned = THREE.MathUtils.clamp(hipAligned + delta, HIP_MIN, HIP_MAX);
            }

            const swingLimitBase = THREE.MathUtils.degToRad(20 + 40 * alignFactor);
            const swingLimit = swingLimitBase * torsoScale;
            hipAligned = THREE.MathUtils.clamp(hipAligned, hipSolve - swingLimit, hipSolve + swingLimit);

            // Blend toward the aligned solution to keep the descent smooth
            const alignWeight = THREE.MathUtils.lerp(START_ALIGN_WEIGHT, START_ALIGN_WEIGHT * 0.45, THREE.MathUtils.clamp(1 - torsoScale, 0, 1));
            const hipBaseBlended = THREE.MathUtils.clamp(
                hipBase + hipBaseOffset * alignWeight,
                HIP_MIN,
                HIP_MAX
            );
            let finalHip = THREE.MathUtils.clamp(
                THREE.MathUtils.lerp(hipBaseBlended, hipAligned, alignFactor),
                HIP_MIN,
                HIP_MAX
            );

            if (previousAnimValue !== null && previousHipAngle !== null) {
                if (t >= previousAnimValue) {
                    finalHip = Math.min(finalHip, previousHipAngle);
                } else {
                    finalHip = Math.max(finalHip, previousHipAngle);
                }
                finalHip = THREE.MathUtils.clamp(finalHip, HIP_MIN, HIP_MAX);
            }

            skeleton.hip.rotation.z = finalHip;
            if (skeleton.leftHip) {
                skeleton.leftHip.rotation.z = finalHip;
            }

            skeleton.ankle.updateWorldMatrix(true, false);

            updateArmAttachments();

            const hipDeg = THREE.MathUtils.radToDeg(finalHip);
            const kneeDeg = Math.abs(THREE.MathUtils.radToDeg(kneeFlex));
            const ankleDeg = Math.abs(THREE.MathUtils.radToDeg(ankleAngle));

            readoutHip.textContent = `${hipDeg.toFixed(1)}°`;
            readoutKnee.textContent = `${kneeDeg.toFixed(1)}°`;
            readoutAnkle.textContent = `${ankleDeg.toFixed(1)}°`;

            previousAnimValue = t;
            previousHipAngle = finalHip;
        }

        function onWindowResize() {
            const w = container.clientWidth;
            const h = container.clientHeight;

            renderer.setSize(w, h);

            const aspect = w / h;
            const viewSize = 6;
            camera.left = -viewSize * aspect / 2;
            camera.right = viewSize * aspect / 2;
            camera.top = viewSize / 2;
            camera.bottom = -viewSize / 2;
            camera.updateProjectionMatrix();
        }

        function animate() {
            requestAnimationFrame(animate);
            if (controls) {
                controls.update();
            }
            renderer.render(scene, camera);
        }

        init();
    </script>
</body>
</html>